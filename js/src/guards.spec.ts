import { guards as g } from './guards'

describe('guards', () => {
  it('works on simple types', () => {
    expect(g.string('foo')).toBe(true)
    expect(g.string(123)).toBe(false)
    expect(g.number(123)).toBe(true)
    expect(g.number(false)).toBe(false)
    expect(g.boolean(false)).toBe(true)
    expect(g.boolean(null)).toBe(false)
    expect(g.true(true)).toBe(true)
    expect(g.true(false)).toBe(false)
    expect(g.false(false)).toBe(true)
    expect(g.false(null)).toBe(false)
    expect(g.null(null)).toBe(true)
    expect(g.null(undefined)).toBe(false)
    expect(g.undefined(void 0)).toBe(true)
    expect(g.undefined([])).toBe(false)
    expect(g.array([])).toBe(true)
    expect(g.array({})).toBe(false)
    expect(g.object({})).toBe(true)
    expect(g.object(null)).toBe(false)
    expect(g.object(() => 0)).toBe(false)
    expect(g.function(() => 0)).toBe(true)
    expect(g.function(0)).toBe(false)

    expect(g.arrayOf(g.number)([1,2,3])).toBe(true)
    expect(g.arrayOf(g.number)([])).toBe(true)
    expect(g.arrayOf(g.number)([1,2,false])).toBe(false)
    expect(g.arrayOf(g.number)(['a', 5])).toBe(false)
    expect(g.arrayOf(g.number)(5)).toBe(false)
    expect(g.arrayOf(g.number)({a: 1})).toBe(false)

    expect(g.objectOf(g.string)({a: '1', b: '2'})).toBe(true)
    expect(g.objectOf(g.string)({})).toBe(true)
    expect(g.objectOf(g.string)({a: '1', b: 2})).toBe(false)
    expect(g.objectOf(g.string)(['1'])).toBe(false)

    expect(g.tupleOf(g.string, g.number)(['a', 1])).toBe(true)
    expect(g.tupleOf(g.string, g.number)(['a', 1, 0])).toBe(false)
    expect(g.tupleOf(g.string, g.number)(['a'])).toBe(false)
    expect(g.tupleOf(g.string, g.number)([1, 'a'])).toBe(false)
    expect(g.tupleOf(g.string, g.number)(1)).toBe(false)
    expect(g.tupleOf(g.string, g.number)('a')).toBe(false)
    expect(g.tupleOf()([])).toBe(true)
    expect(g.tupleOf()([0])).toBe(false)

    expect(g.functionOf(1)(() => 0)).toBe(false)
    expect(g.functionOf(1)((a: unknown) => 0)).toBe(true)
    expect(g.functionOf(1)((a: unknown, b: unknown) => 0)).toBe(false)
  })

  it('can combine types', () => {
    const a = g.null.or(g.number).or(g.tupleOf(g.number, g.arrayOf(g.string)))

    expect(a(null)).toBe(true)
    expect(a(0)).toBe(true)
    expect(a([0, []])).toBe(true)
    expect(a([0, ['one']])).toBe(true)
    expect(a([0, ['one', 'two']])).toBe(true)

    expect(a(false)).toBe(false)
    expect(a(undefined)).toBe(false)
    expect(a([0, [1]])).toBe(false)
    expect(a(['0', ['one']])).toBe(false)
    expect(a([0, ['one', null, 'two']])).toBe(false)
  })
})
